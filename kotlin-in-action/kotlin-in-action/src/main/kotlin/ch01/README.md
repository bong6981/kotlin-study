코틀린이란 무엇이며 왜 필요한가 
# 1.1 코틀린 맛보기
```kotlin
data class Person(val name: String, // 데이터 클래스 
val age: Int? = null) // null 이 될 수 있는 타입(Int?)와 파라미터 디폴트 값

fun main(args: Array<String>) {
    val persons = listOf(Person("영희"),
    Person("철수", age = 29)) // 이름 붙인 파라미터
    val oldest = persons.maxBy { it.age ?: 0 } // 람다식과 엘비스 연산자
    println("나이가 가장 많은 사람: $oldest") // 문자열 템플릿
}
// 결과 : 나이가 가장 많은 사람: Person(name=철수, age=29) // toString 자동 생성
```
- 엘비스 연산자 라고 부르는 ?:는 특성  age가 null일 경우 0을 반환, 그렇지 않을 경우 age

# 1.2 코틀린의 주요 특성
## 1.2.1 대상 플랫폼: 서버, 안드로이드 등 자바가 실행되는 모든 곳 
## 1.2.2 정적 타입 statically type 지정 언어 
- 자바와 코틀린은  정적 타입 statically typed 지정 언어 
- 정적 타입 지정 언어 
  - 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻
  - 동적 타입 지정 언어 dynamically typed
    - Groovy, JRuby
    - 타입과 관계없이 모든 값을 변수에 넣을 수 있고
    - 메서드나 필드 접근에 대한 검증이 실행 시점에 일어나며 
    - 그에 따라 코드가 더 짧아지고 데이터 구조를 더 유연하게 생성하고 사용할 수 있다
    - 이름을 잘못 입력하는 드으이 실수도 컴파일시 걸러내지 못하고 실행 시점에 오류가 발생한다. 
- 코틀린 타입 추론 type Inference
  - 자바와 달리 코틀린에서는 모든 변수의 타입을 프로그래머가 직접 명시할 필요가 없다 
  - 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추
  ```kotlin
    var x = 1
  ```
  - 코틀린은 타입추론을 지원해 정적 타입 지정 언어에서 프로그래머 직접 타입을 선언해야 함에 따라 생기는 불편함이 대부분 사라진다.
- 정적 타입 지정의 장점 
  - 성능 : 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없어 메서드 호출이 더 빠르다
  - 신뢰성 : 컴파일러가 프로그램의 정확성 correctness를 검증하기 때문에 실행시 프로그램이 오류로 중단될 가능성이 적다
  - 유지 보수성 : 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있어 처음 보는 코드를 다루기 더 쉽다
  - 도구 지원 : 정적 타입 지정을 활용하면 더 안전하게 리팩토링 할 수 있고 도구는 더 정확한 코드 완성 기능을 제공할 수 있으며 IDE의 다른 지원 기능도 더 잘 만들 수 있다 
- 코틀린이 자바라 다는 특성
  - 널이 될 수 있는 타입 nullable type을 지원
    - 널 포인터 예외가 발생할 수 있는지 여부를 검사할 수 있어 좀 더 프로그램의 신뢰성을 높일 수 있다 
  - 함수 타입 funtion type 에 대한 지원 

## 1.2.3 함수형 프로그래밍프로그래밍 과 객체지향 
- 함수형 프로그래밍의 핵심 개념
  - 일급 시민인 first class 함수 
    - 함수를 일반 값처럼 다룰 수 있다 
      - 함수를 변수에 저장할 수 있고 함수를 인자로 다른 함수에 전달 가능, 함수에서 새로운 함수를 만들어 반환 가능 
  - 불변성
    - 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성 
  - 부수 효과 없음
    - 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수 pure function을 사용한다 
- 함수형 스타일 프로그램 작성의 장점 
  - 간결성
    - 함수를 값처럼 활용할 수 있으면 더 강력한 추상화를 할 수 있고 강력한 추상화 도구를 사용해 코드 중복을 막을 수 있다 
    - 예를 들어 세밀한 부분이 같은 두 가지 함수에서 공통 부분을 뽑아내고 서로 다른 세부사항을 인자로 전달가능
    ```kotlin
    fun findAlice() = findPerson ( it.name == "Alice" )
    fun findBob() = findPerson ( it.name == "Bob" )
    ```
  - 다중 스레드를 사용해도 안전 safe multithreading 
    - 다중 스레드 프로그램에서는 적절한 동기화 없이 같은 데이터를 여러 스레드가 변경하는 경우 가장 많은 문제가 생긴다.
    - 불변 데이터 구조를 사용하고 순수함수를 그 데이터 구조에 적용하면 다중 스레드 환경에서 여러 스레드가 변경할 수 없다. 복잡한 동기화를 사용하지 않아도 된다. 
  - 테스트하기 쉽다. 
    - 부수 효과가 있는 함수는 그 함수를 실행할 때 필요한 전체 환경을 구성하는 코드 setup code가 필요하지만 순수 함수는 그런 준비 코드 없이 독립적으로 테스트 할 수 있다.

모든 언어에서 함수형 프로그래밍 작성이 가능하지만 모든 언어가 함수형 프로그래밍을 편하게 사용하기에 충분한 라이브러리와 문법 지원을 제공하지는 않는다. 코틀린은 처음부터 함수형 프로그래밍을 풍부하게 지원해 왔다. 
- 코틀린의 함수형 프로그래밍 지원
  - 함수 타입을 지원함에 따라 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다
  - 람다 식을 지원해서 번거로운 준비 코드를 작성하지 않아도 코드 블록을 쉽게 정의하고 여기저기 전달 가능
  - 데이터 클래스는 불변적인 값 객체 value object를 간편하게 만들 수 있는 구문을 제공한다 
  - 코틀린 표준 라이브러리는 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공 
- 코틀린으로 코드를 작성할 떄는 객체지향과 함수형 접근 방법을 조합하여 사용 가능
  - 코틀린이 함수형 프로그래밍 스타일을 강요하는 언어는 아님
  - 명령형 방식이 더 적합하다면 명령형 방식으로 작성 가능
  
# 1.3 코틀린 응용 
## 1.3.1 코틀린 서버 프로그래밍(에 적합한 이유)
- 서버 프로그래밍 언어로 오랫동안 쓰여 있던 자바와 상호운용성 
- 몇 가지 새로운 기술을 활용해 서버 시스템 개발 가능 
  - 코틀린의 빌더 패턴 : 간결한 구문을 사용해 객체로 이뤄진 그래프 graph를 쉽게 구축하면서도 코틀린이 제공하는 완전한 추상화와 코드 재활용을 지속적으로 누릴 수 있다
    - 대표적인 예 : HTML 생성 라이브러리 : 외부 HTML 템플릿 라이브러리 대신해 더 간결하면서 타입 검사를 완전히 지우너하는 안전한 해법 제공 
    ```kotlin
    
    fun renderPersonList(persons: Collection<Person>) =
      createHTML().table {
        for (person in persons) {
            tr {
                td { +person.name }
                td { +person.age }
            }   
        }
      }
    ```
    - HTML 페이지를 생성하면서 코틀린 루프 등의 일반적인 코틀린 기능 활용 가능
  - 코틀린이 제공하는 깔끔 간결한 DSL 기능을 활용할 수 있는 다른 예 : 영속성 persistence 프레임워크 
    - 예를 들어 exposed 프레임워크는 SQL 데이터베이스 구조를 기술 할 수 있는 읽기 쉬운 DSL을 제공하며 코틀린 코드만을 사용해 완전한 타입 검사를 지원하면서 데이터 베이스 질의를 실행할 수 있다

## 1.3.2 코틀린 안드로이드 프로그래밍 
- 코틀린을 사용해도 성능 측면에서 아무 손해가 없다 
  - 코틀린 컴파일러가 생성한 바이트코드는 일반적인 자바 코드와 똑같이 효율적으로 실행
  - 코틀린의 런타임 시스템은 상당히 작아 컴파일 후 패키징한 애플리케이션 크기도 자바 애플리케이션에 비해 그리 많이 늘어나지 않는다
  - 코틀린 표준 라이브러리 함수는 인자로 받는 람다 함수를 인라이닝 inlining 한다
    - 람다를 사용해도 새로운 객체가 만들어지지 않아 객체 증가로 인해 가바지 컬렉션이 늘어나 프로그램이 자주 멈추는 일도 없다 

# 1.4 코틀린의 철학 

## 1.4.1 실용성 

## 1.4.2 간결성 
- 어떤 언어가 간결하다는 말은 그 언어로 작성된 코드를 읽을 때 의도를 쉽게 파악할 수 있는 구문 구조를 제공하고 그 의도를 달성하는 방법을 이해할 때 방해가 될 수 있는 부가적인 준비 코드가 적다는 뜻
  - 게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등 : 준비코드 제거 

## 1.4.3 안전성
- 안정성과 생산성 사이는 트레이드 오프 trade off 관계
- 코틀린을 JVM에서 실행한다는 것은 이미 상당한 안전성을 보장할 수 있다는 뜻
  - 메모리 안정성 보장, 버퍼 오버플로우 방지, 동적으로 할당된 메모리 잘못 사용해서 생기는 문제들 예방
  - JVM에서 실행되는 정적 타입 지정 언어로서 애플리케이션의 타입 안정성을 보장
- 하지만 자바보다 더 적은 비용으로 타입 안정성 사용 가능 
  - 코틀린 컴파일러가 대부분의 타입 추론 
- 더 나아가 코틀린은 실행 시점 대신 컴파일 시점 검사를 통해 오류 더 많이 방지 
  - 코틀린은 프로그램의 NullPointException을 없애기 위해 노력 
    - 코틀린이 타입 시스템은 null이 될 수 없는 값을 추적하며 실행 시점에 NullPointException이 발생할 수 있는 연산을 사용하는 코드를 금지한다
    - 이를 위해 추가로 들어가는 비용은 미미 : ? 한 글자만 추가하면 된다 
  - 코틀린이 방지해는 주는 또 다른 예외 : ClassCastException
    - 어떤 객체를 다른 타입으로 캐스트 하기 전에 타입 검사 하지 않으면 발생할 수 있는 예외
    - 코틀린에서느 타입 검사와 캐스트가 한 연산자에 의해 이뤄진다 
      - 어떤 객체의 타입을 검사했고 그 객체가 그 타입에 속한다면 해당 타입의 메서드나 필드 등의 멤버를 별도의 캐스트 없이 사용 가능
      ```kotlin
      if (value is String)
        println(value.toUpperCase())
      ```

## 1.4.4 상호운용성 interoperability

- 코틀린 코드나 메서드를 자바 코드 코드 안에서 자바 클래스나 메서드와 똑같이 사용할 수 있다
- 코틀린은 기존 자바 라이브러리를 가능하면 최대한 활용
  - 코틀린은 자바 표준 라이브러리 클래스에 의존
  - 다만 코틀린에서 컬렉션을 더 쉽게 사용할 수 있게 몇 가지 기능을 더할 뿐

# 1.5 코틀린 도구 사용

## 1.5.1 코틀린 코드 컴파일 
- 자바 소스 코드를 컴파일 할 때와 마찬가지로 코틀린 소스코드를(.kt) 분석해서 .class 파일 만든다.
- 가장 간단한 방식은 커맨드라인에서 kotlinc 명령어 통해 코틀린 코드 컴파일하고 java 명령으로 실행하는 것
```
kotlinc <소스파일 혹은 디렉토리> -include-runtime -d <jar 이름>
java -jar <jar 이름>
```
- .kt 코드는 코틀린 컴파일러로 .java 코드는 자바 컴파일러로 컴파일해서 .class파일 만든다 
- .class 파일을 .jar 로 만드는 것은 똑같다 
- 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리에 의존
  - 런타임 라이브러에는 코틀린 자체 표준 라이브러리 클래스와 코틀린에서 자바 API를 확장한 내용이 들어 있다
  - 코틀린으로 컴파일한 애플리케이션을 배포할 때는 런타임 라이브러리도 함께 배포해야한다
  - maven, gradle 빌드 시스템은 애플리케이션을 패키지 할 때 알아서 코틀린 런타임을 포함

## 1.5.3 대화형 셀
- REPL 입력을 받아 값을 계산한 다음 결과 값을 출력하는 루프라는 뜻의 read-eval-print loop
- REPL에서 코틀린 코드를 한 줄 입력하면 즉시 그 코드를 실행한 결과를 볼 수 있다 
- REPL 실행하려면 kotlinc 명령을 아무 인자 없이 실행허거나
- 인텔리제이 메뉴(툴-코틀린-코틀린REPL)

## 1.5.6 자바-코틀린 변환기
- 작성하고픈 코드를 자바로 작성해 복사해서 코틀린 파일에 그 코드를 붙이면 변환기가 자동으로 같은 뜻의 코틀린 코드 제안
- 자바 파일 하나를 통째로 코틀린으로 변환하고 싶으면 
  - 코드 - 자바 파일을 코틀린 파일로 변환 을 선택
