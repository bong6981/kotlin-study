5. 람다로 프로그래밍
- 람다식, 또는 람다는 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 뜻한다 
- 람다를 사용하면 쉽게 공통 코드 구조를 라이브러리 함수로 뽑아낼 수 있다 
- 코틀린 표준 라이브러리는 람다를 아주 많이 사용한다 
- 람다를 자주 사용하는 경우로 컬렉션 처리를 들 수 있다 

# 5.1 람다 식과 멤버 참조 
- 자바 8의 람다는 기다려온 람다의 도입 
- 왜 람다가 그렇게 중요할까?

## 5.1.1 람다 소개: 코드 블록을 함수 인자로 넘기기 
- "이벤트가 발생하면 이 핸들러를 실행하자"나 "데이터 구조의 모든 원소에 이 연산을 적용하자"와 같은 생각을 표현하기 위해 일련의 동작을 변수에 저장하거나 다른 함수에 넘겨야 하는 경우가 자주 있다 
- 예전에 자바에서는 무명 내부 클래스를 통해 이런 목적을 달성했다 
- 무명 내부 클래스를 사용하면 코드를 함수에 넘기거나 변수에 저장할 수 있기는 하지만 상당히 번거롭다 
- 함수형 프로그래밍에서는 함수를 값처럼 다루는 접근 방법을 택해서 이 문제를 해결 
- 클래스 선언, 클래스의 인스턴스를 함수에 넘기는 대신 
- 함수형 언어에서는 함수를 직접 다른 함수에 전달할 수 있다 
- 람다 식을 사용하면 코드가 더 간결해진다 
  - 람다식을 사용하면 함수를 선언할 필요가 없고, 코드 블록을 직접 함수의 인자로 전달할 수 있다 
- 예제
  - 버튼 클릭에 따른 동작을 정의하고 싶을 때 
  - 클릭 이벤트를 처리하는 리스너 추가 
  - 버튼 클릭 리스너는 onClick이라는 메서드가 들어있는 onClickListener를 구현해야 한다 
```java
button.setOnClickListener(new onClickListener() {
    @Override
    public void onClick(View view) {
        ///...
    }
})
```
- 무명 내부 클래스를 선언하느라 코드가 번잡스럽다 
- 람다로 리스너 구현하기 
```kotlin
button.setOnClickListenr {/* 클릭시 수행할 동작 */}
```
- 이 코드는 자바 무명 내부 클래스와 같은 역할을 하지만 훨씬 더 간결하고 읽기 쉽다 
- 이 예제는 람다를 메서드가 하나뿐인 무명 객체 대신 사용할 수 있다는 사실을 보여준다 
- 이제 함수형 언어에서 전통적으로 람다를 많이 활용해온 컬렉션에 대해 살펴보자 

## 5.1.2 람다와 컬렉션 
- 코드에서 중복을 제거하는 것은 프로그래밍 스타일을 개선하는 중요한 방법 중 하나다. 
- 컬렉션을 다룰 때 수행하는 대부분의 작업은 몇 가지 일반적인 패턴에 속한다 
- 따라서 그 패턴은 라이브러리 안에 있어야 한다 
- 하지만 람다가 없다면 컬렉션을 편리하게 처리할 수 있는 좋은 라이브러리를 제공하기 힘들다 
- 그런 이유로 (자바 8 이전에는) 자바에서 쓰기 편한 컬렉션 라이브러리가 적었으며 
- 그에 따라 자바 개발자들은 필요한 컬렉션 기능을 직접 작성하곤 했다 
- 코틀린에서는 이런 습관을 버려야 한다 
```kotlin
data class Person (val name: String, val age:Int)
```
- 사람들로 이루어진 리스트가 있고, 그 중에 가장 연장자를 찾고 싶다. 
- 람다를 사용해본 경험이 없는 개발자라면 루프를 써서 직접 검색을 구현할 것 
- 리스트 5.3 컬렉션을 직접 검색하기 
```kotlin
fun findTheOldest(people: List<Person>) {
    var maxAge = 0 // 가장 많은 나이 저장 
    var theOldest: Person? = null 
    for (person in people) {
        if (person.age > maxAge) {
            maxAge = person.age
            theOldest = person
        }
    }
    println(theOldest)
}
```
- 이런 로직을 매번 직접 짜다 보면 실수를 하기가 쉽다 
- 코틀린에서는 더 좋은 방법 : 라이브러리 함수 쓰기 
- 리스트 5.4 람다를 사용해 컬렉션 검색하기 
```kotlin
fun main(args: Array<String>) {
    val people = listOf(Person("Alice", 29), Person("Bob", 31))
    println(people.maxBy { it.age })  // Person(name=Bob, age=31)
}
```
- 모든 컬렉션에 대해 maxBy를 호출할 수 있다 
- maxBy는 가장 큰 우너소를 찾기 위해 비교에 사용할 값을 돌려주는 '함수'를 인자로 받는다
- 중괄호로 둘러싸인 코드 { it.age }는 바로 비교에 사용할 값을 돌려주는 함수다 
- 이 코드의 컬렉션의 원소를 인자로 받아서 (it가 그 인자를 가리킨다) 비교에 사용할 값을 반환한다 
- 이 예제에서는 컬렉션의 우너소가 Peerson 객체였으므로 이 함수가 반환하는 값은 Person 객체의 age 필드에 저장된 나이 정보다 
- 이런식으로 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 함수를 람다는 멤버 참조로 대치할 수 있다 
```kotlin
@Deprecated("Use maxByOrNull instead.", ReplaceWith("this.maxByOrNull(selector)"))
@DeprecatedSinceKotlin(warningSince = "1.4", errorSince = "1.5", hiddenSince = "1.6")
@Suppress("CONFLICTING_OVERLOADS")
public inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {
    return maxByOrNull(selector)
}
```
- 리스트 5.5 멤버 참조를 사용해 컬렉션 검색하기 
```kotlin
people.maxBy(Person::age)
```
- 이 코드는 리스트 5.4와 같은 역할을 한다. 
- 자바 컬렉션에 대해(자바 8이전에) 수행하던 대부분의 작업은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선할 수 있다 
- 그렇게 람다나 멤버 참조를 인자로 받는 함수를 통해 개선한 코드는 더 짧고 더 이해하기 쉽다 

## 5.1.3 람다 식의 문법 
- 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음이다 
- 람다를 따로 선언해서 변수에 저장할 수도 있다 
- 하지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분 
- 람다식을 선언하기 위한 문법 (아래)
```kotlin
{ x : Int, y : Int -> x + y } 
```
- 코틀린 람다식은 항사 중괄호로 둘러싸여 있다 
- 인자 목록 주변에 괄호가 없다는 사실을 꼭 기억하라 
- 화살표(->)가 인자 목록과 람다 본문을 구분해준다 
- 
- 람다 식을 변수에 저장할 수 있다 
- 람다가 저장된 변수를 다른 일반 함수와 마찬가지로 다룰 수 있다 
  - 변수 이름 뒤에 괄호를 놓고 그 안에 필요한 인자를 넣어서 람다를 호출할 수 있다 
```kotlin
val sum = {x: Int, y: Int -> x + y}
println(sum(3, 5))
```
- 원한다면 람다식을 직접 호출해도 된다 
```kotlin
{ println(42) }() //42
```
- 하지만 이는 읽기 어렵고 쓸모도 없다 
- 굳이 람다를 만들자마자 호출하느니 람다 본문을 직접 실행하는 편이 낫다 
- 이렇게 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 run을 사용한다 
- run은 인자로 받은 람다를 실행해주는 라이브러리 함수다 
```kotlin
 run{ println(42) } // 람다 본문에 있는 코드를 실행한다
```
- 실행 시점에 코틀린 람다 호출에는 아무 부가 비용이 들지 않으며, 프로그램의 기본 구성 요소와  비슷한 성능을 낸다. 
- 8.2 절에서 그 이유 설명 
```kotlin
val people = listOf(Person("Alice", 29), Person("Bob", 31))
println(people.maxBy { it.age })
```
- 이 예제에서 코틀린이 코드를 줄여 쓸 수 있게 제공했던 기능을 제거하고 정식으로 람다를 작성하면 다음과 가탇 
```kotlin
    println(people.maxBy({p: Person -> p.age}))
```
- 중괄호 안에 코드는 람다식이고 그 람다식을 maxBy한테 넘긴다. 
- 람다식은 Person 타입의 값을 인자로 받아서 인자의 age를 반환한다 
- 하지만 이 코드는 번잡
  - 구분자가 너무 많이 쓰여서 가독성이 떨어짐 
  - 컴파일러가 문맥으로부터 유추할 수 있는 인자타입을 굳이 적을 필요가 없다 
  - 마지막으로 인자가 단 하나뿐인 경우 굳이 인자에 이름을 붙이지 않아도 된다 
- 이 개선을 적용해 보자 
- 중괄호 부터 시작 : 코틀린에는 함수 호출시 맨 뒤에 있는 인자가 람다 식이라면 그 람다를 괄호 밖으로 빼낼 수 있는 문법 관습이 있다 
  - 이 예제에서는 람다가 유일한 인자, and 마지막 인자 
  - 따라서 괄호 뒤에 람다를 둘 수 있다 
```kotlin
    println(people.maxBy() {p: Person -> p.age})
```
- 이 코드처럼 람다가 어떤 함수의 유일한 인자고, 괄호 뒤에 람다를 썼다면 호출시 괄호를 생략 가능 
```kotlin
   println(people.maxBy {p: Person -> p.age})
```
- 이 세가지 형태는 모두 같은 뜻이지만 마지막 문장이 가장 읽기 쉽다 
- 람다가 함수의 유일한 인자라면 여러분은 분명 괄호 없이 람다를 바로 쓰기를 원하게 될 것이다 
- 인자가 여럿 있는 경우에는 람다를 밖으로 빼낼 수도 있고 람다를 괄호 안에 유지해서 함수의 인자임을 분명히 할 수 도 있다
- 둘 이상의 람다를 인자로 받는 함수라고 해도 인자 목록의 맨 마지막 람다만 밖으로 뺄 수 있다 
- 따라서 그런 경우에는 괄호를 사용하는 일반적인 함수 호출 구문을 사용하는 편이 낫다 
- 표준 라이브러리의 joinToString은 매 마지막 인자로 함수를 받는다 
  - 리스트의 원소를 toString이 아닌 다른 방식으로 문자열로 변환하고 싶은 경우 이 인자를 활용한다 
- 리스트 5.6 이름 붙인 인자를 사용해 람다를 넘기기 
```kotlin
    val people = listOf(Person("이몽룡", 29), Person("성춘향", 31))
    val names = people.joinToString(separator = " ",
        transform = { p: Person -> p.name })
    println(names) // 이몽룡 성춘향
```
- 이 함수 호출에서 함수를 괄호 밖으로 뺀 모습은 다음과 같다 
```kotlin
people.joinToString(separator = " ") {
            p: Person -> p.name
    }
```
- 리스트 5.6에서는 이름 붙인 인자를 사용해 람다를 넘겨서 람다를 어떤 용도로 쓰는지 더 명확히 했다 
- 리스트 5.7은 더 간결하지만 람다의 용도를 분명히 알 수는 없다 5.7이 더 어려울 것
- 리스트 5.8 람다 파라미터 타입 제거하기 
```kotlin
 println(people.maxBy {p: Person -> p.age}) // 파라미터 타입 명시 
 println(people.maxBy {p -> p.age}) // 파라미터 타입 생략 (컴파일러 추론)
```
- 로컬 변수처럼 컴파일러는 람다 파라미터의 타입도 추론할 수 있다 
- 따라서 파라미터 타입을 명시할 필요가 없다 
- maxBy 함수의 경우 파라미터의 타입은 항상 컬렉션 원소 타입과 같다 
- 컴파일러는 여러분이 Person 타입의 객체가 들어있는 컬렉션에 대해 maxyby 를 호출할 수 있다는 사실을 알고 있어 람다의 파라미터도 Person이라는 사실을 이해할 수 있다 
- 컴파일러가 타입 추론을 못할 때도 있다 그 때만 타입을 명시해라 
- 파라미터 중 일부만 타입을 지정하고 나머지는 타입 지정 없이 이름만 남겨둬도 된다 
- 컴파일러가 파라미터 타입 중 일부를 추론하지 못하거나 타입 정보가 코드를 읽을 때 도움이 된다면 그렇게 일부 타입을 명시해도 ok 
- 람다의 파라미터 이름을 디폴트 이름인 it로 바꾸면 람다 식이 더 간결해진다
- 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 it을 바로 쓸 수 있다 
```kotlin
 println(people.maxBy {it.age})
```
- 람다의 파라미터 이름을 따로 지정하지 않은 경우메나 it라는 이름이 자동으로 만들어진다 
- 노트
  - it는 코드를 간결하게 만들어주지만 남발하면 안된다 
  - 람다 안에 람다가 중첩되는 경우 각 람다의 파라미터를 명시하는 것이 난다
- 람다를 변수에 저장할 때는 파라미터 타입을 추론할 문맥이 존재하지 않는다. 따라서 파라미터 타입을 명시해야 한다 
```kotlin
val getAge = {p: Person -> p.age}
people.maxBy(getAge)
```
- 여러 줄로 이뤄진 람다도 있다 
```kotlin
val sum = { x: Int, y: Int ->
  println("$x and $y ...")
  x + y
}
```
- 본문이 여러 줄로 이뤄진 경우 본문의 맨 마지막에 있는 식리 람다의 결과 값
