# 6.1.1 널이 될 수 있는 타입 
- 코틀린과 자바의 첫 번째이자 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점이다 
- 널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에  null 을 허용하게 만드는 방법이다 
- 어떤 변수가 널이 될 수 있다면 그 변수에 대해 ( 그 변수를 수신 객체로 ) 메서드를 호출하면 NullPointerException 이 발생할 수 있으므로 안전하지 않다 
- 코틀린은 그런 메서드 호출을 금지함으로써 많은 오류를 방지한다 
```java
int strLen(String s) {
    return s.length
}
```
- 이 함수가 안전한가? 이 함수에 null을 넘기면 NullpointerException이 발생한다 
  - 그렇다면 이 함수에서 s가 null인지를 꼭 검사해야 할까?
  - 검사가 필요할지 여부는 이 함수를 사용하는 의도에 따라 달라진다 
- 이 함수를 코틀린으로 다시 작성해보자
  - 코틀린에서 이런 함수를 작성할 때 가장 먼저 답을 알아야 할 질문은 이 함수가 널을 인자로 받을 수 있는가다 
  - 여기서 널을 인자로 받을 수 있다는 말은
    - strLen(null) 처럼 직접 null 리터럴로 사용하는 경우 뿐 아니라 
    - 변나 식의 값이 실행 시점에 null이 될 수 있는 경우를 모두 포함한다 
- 널이 자로 들어올 수 없다면 코틀린에서는 다음과 같이 함수를 정의할 수 있다 
```kotlin
fun strLen(s: String) = s.length
```
- strLen 에 null 이나 null 이 될 수 있는 값을 넘기는 것은 금지되면 혹시 그런 값을 넘기면 컴파일 시 오류가 발행한다 
- 따라서 strLen 함수가 결코 실행 시점에 nullpointerexception 을 발생시키지 않으리라 장담할 수 있다 
- 이 함수가 널과 문자열을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표를 명시해야 한다 
```kotlin
fun strLen(s: String?) = s.length
```
- 어떤 타입이든 이름 뒤에 물음표를 붙이면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다 
- 다시 말하지만 물음표가 없는 타입은 그 변수가 null 참조를 저장할 수 없다는 뜻이다 
  - 따라서 모든 타입은 기본적으로 널이 될 수 없는 타입 
  - 뒤에 ? 가 붙어야 널이 될 수 있다 
- 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다 
- 예를 들어 널이 될 수 있는 타입인 변수에 대해 변수.메서드() 처럼 메서드를 직접 호출할 수 없다 
```kotlin
fun strLen(s: String?) = s.length // 이거 에러. (?.) 또는 (!!) 를 써야 한다
```
- 널이 될 수 있있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 는 없다. 
```kotlin
val x :String? = null
var y? String = x // 에러
```
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달 할 수 없다 
- 이렇게 제약이 많다면 널이 될 수 있는 타입의 값으로 대체 뭘 할 수 있을까?
- 가장 중요한 일은 바로 null 과 비교하는 것 
- 일단 null 과 비교하고 나면 컴파일러는 그 사실을 기억하고 null 이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입의 값처럼 사용할 수 있다 
```kotlin
fun strLenSafe(s: String?): Int = 
    if (s != null) s.length else 0 // 널 검사를 추가하면 코드가 컴파일 된다 

val x : String? = null
println(strLenSafe((x)))
println(strLenSafe("abc"))
```
- 널 가능성을 다루기 위해 사용할 수 있 도구가 if 검사뿐이라면 코드가 번잡
- 다행히 코틀ㅇㄴ 널이 될 수 있는 값을 다룰 때 도움이 되는 여러 도구를 제공한다

