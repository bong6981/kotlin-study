# 코틀린답게 사용하기 
- 코틀린에서는 언어 기능이 어떤 타입 (클래스)와 연관되기 보다는 특정 함수 이름과 연관된다. 
- 예를들어 어떤 클래스 안에 plus라는 이름의 특별한 메서드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다 
- 이런식으로 어떤 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례 convention 이라고 부른다. 
- 7장에서는 코틀린이 지원하는 여러 관례와 그 관례의 사용법을 살펴본다 
- 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 (함수 이름을 통한) 관례에 의존한다 

# 7.1 산술 연산자 오버로딩 
- 코틀린에서 관례를 사용하는 가장 단순한 예는 산술 연산자 
- 저버애소눈 원시 타입에 대해서만 살술 연산자를 사용할 수 있고 추가로 String 에 대해 + 연산자를 사용할 수 있다 
- 코틀린에서는 다른 클래스에서 산술 연산자가 유용한 경우에 이를 사용하게 할 수 있다 

## 7.1.1. 이항 산술 연산 오버로딩 
- 두 점을 더하는 연산 
- 리스트 7.1 plus 연산자 구현하기 
```kotlin
data class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}
```
```kotlin
fun main(args: Array<String>) {
    val p1 = Point(10, 20)
    val p2 = Point(30, 40)
    println(p1 + p2) // Point(x=40, y=60)
}
```
- plus 함수 앞에 operator 키워드를 붙여야 한다. 
  - 연산자를 오버로딩 하는 함수 앞에는 꼭 operator가 있어야 한다 
  - operator 붙여서 어떤 함수가 관레를 따를 함수임을 명확히 할 수 있다 
  - operator 가 없는데 실수록 관레에서 사용하는 함수 이름을 쓰고 우연히 그 이름에 해당하는 기능을 사용하면 
    - operator modifier is required ... 오류를 통해 이름이 겹쳤다는 사실을 알고 문제 해결 가능 
- 연산자를 멤버 함수로 만드는 대신 확장 함수로 정의할 수 있다 
```kotlin
operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}
```
- 코틀린에서는 프로그래머가 직접 연산자를 만들어 사용할 수 없고 언어에서 미리 정해둔 연산자만 오버로딩 할 수 있으며 관례에 따릐기 위해 클래스에서 정의해야 하는 이름이 연산자별로 정해져 있다 
>> a * b // times 
> a / b // div 
> a % b // mod(1.1부터 rem)
> a + b // plus
> a - b // minus 
- 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선 순위와 같다
  - 예를 들어 a + b * c 라는 식에서 언제나 곱셈이 항상 덧셈보다 먼저 수행 
  - * / % 는 모두 우선순위가 같고, 이 셋의 우선순위는 + - 보다 높다 
- 연산자 함수와 자바 
  - 코틀린 연산자를 자바에서 호출하기는 쉽다 
    - 모든 오버로딩한 연산자는 함수로 정의되며 
    - 긴 이름 fqn를 사용하면 일반 함수로 호출할 수 있다 
  - 자바를 코틀린에서 호출하는 경우네는 함수의 이름이 코틀린의 관례에 맞아 떨어지기만 하면 연산자 식을 사용해 그 함수를 호출할 수 있다 
  - 자바에서는 따로 연산자에 표시할 수 없어 operator 변경자를 사용해야 한다는 요구사항을 자바 메서드에 적용할 수는 없다 
  - 따라서 이름과 파라미터 개수만 문제가 된다 
  - 자바 클래스에 여러분이 원하는 연산자 기능을 제공하는 메서드가 이미 있지만 이름만 다르다면 관례에 맞는 이름을 가진 확장 함수를 작성하고 연산을 기존 바자 메서드에 위임 
- 연산자를 정의할 때 두 피연산자 (연산자 함수의 두 파라미터)가 같은 타입일 필요는 없다 
- 리스트 7.3 두 피연산자의 타입이 다른 연산자 
```kotlin
operator fun Point.times(scale: Double): Point {
    return Point((x * scale).toInt(), (y * scale).toInt())
}
```
```kotlin
val p = Point(10, 20)
println(p * 1.5) // Point(x=15, y=30)
```
- 코틀린 연산자가 자동으로 교환 법칙 commutativity ( a op b == b op a) 을 지원하지는 않음에 유의 
- 사용자가 p * 1.5 1.5 * p 둘 다 쓸 수 있게 하려면 operator fun Double.times(p: Point): Point를 더 정의해야 한다 
- 연산자 함수의 반환 타입이 꼭 두 피연산자 중 하나만 일치해야 하는 것도 아니다 
- 리스트 7.4 결과 타입이 피 연산자와 다른 연산자 정의하기 
```kotlin
operator fun Char.times(count: Int) :String {
  return toString().repeat(count)
}
```
```kotlin
    println('a' * 3) // aaa
```
- 이 연산자를 char를 좌항으로 받고 int를 우항으로 받아서 string 을 돌려준다. 이것도 완전 합법적 
- 일반 함수와 마찬가지로 operator 함수도 오버로딩 가능 
  - 따라서 이름은 같지만 파라미터 타입이 서로 다른 연산자 함수를 여럿 만들 수 있다 
- 비트 연산자에 대해 특별한 연산자 함수를 사용하지 않는다 
  - 코틀린은 표준 숫자 타입에 대해 비트 연산자를 정의하지 않는다 
  - 따라서 커스텀 타입에서 비트 연산자를 정의할 수도 없다 
  - 대신 중위 연산자 표기법을 지원하는 일반 함수를 사용해 비트 연산 수행 
  - 커스텀 타입에서도 비슷한 함수 정의해 사용할 수 있다 
  - 다음은 코틀린에서 비트 연산을 수행하는 함수의 목록 
    - shl - 왼쪽 쉬프트 자바 << 
    - shr - 오른쪽 쉬프트 자바 >> 
    - ushr - 오른쪽 쉬프트 (0으로 부호비트 설정, 자바 >>>)
    - and - 비트 곱 ( 자바 & )
    - or - 비트 합 (자바 | )
    - xor - 비트 배타 (자바 ^)
    - inv - 비트 반전 ( 자바 ~)
    ```kotlin
    println(0x0F and 0xF0) // 0
    println(0x0F or 0xF0) // 255
    println(0x1 shl 4) // 16
    ```
